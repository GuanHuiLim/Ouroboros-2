#version 460
#extension GL_GOOGLE_include_directive : enable

#include "shader_utility.shader"
#include "lightingEquations.shader"

layout (local_size_x = 16, local_size_y = 16) in;
layout (set=0, binding = 2, rg16f) uniform writeonly image2D resultImage;

layout(push_constant)uniform PushBloomConstant
{
float c_roughness;
};

const uint NUM_SAMPLES = 1024u;

vec2 IntegrateBRDF(float NdotV, float roughness)
{
   // Normal always points along z-axis for the 2D lookup 
    const vec3 N = vec3(0.0, 0.0, 1.0);
    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);

    vec2 LUT = vec2(0.0);
    for (uint i = 0u; i < NUM_SAMPLES; i++)
    {
        vec2 Xi = Hammersley(i, NUM_SAMPLES);
        vec3 H = ImportanceSampleGGX(Xi, roughness, N);
        vec3 L = 2.0 * dot(V, H) * H - V;

        float dotNL = max(dot(N, L), 0.0);
        float dotNV = max(dot(N, V), 0.0);
        float dotVH = max(dot(V, H), 0.0);
        float dotNH = max(dot(H, N), 0.0);

        if (dotNL > 0.0)
        {
            float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);
            float G_Vis = (G * dotVH) / (dotNH * dotNV);
            float Fc = pow(1.0 - dotVH, 5.0);
            LUT += vec2((1.0 - Fc) * G_Vis, Fc * G_Vis);
        }
    }
    return LUT / float(NUM_SAMPLES);
}

void main()
{	
	
    ivec2 outputSize = imageSize(resultImage);
    vec2 uv = (vec2(gl_GlobalInvocationID) + 0.5) / outputSize;
	
    vec2 result = IntegrateBRDF(uv.x, uv.y);
    
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result.xy, 0.0, 1.0));
	
}
