#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : require

#include "shared_structs.h"
#include "shader_utility.shader"

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0/*,rgba16f*/)  uniform sampler basicSampler;
layout (binding = 1/*,rgba16f*/)  uniform texture2D inputImage;
layout (binding = 2,r11f_g11f_b10f) uniform  image2D resultImage;

layout (binding = 3) readonly buffer Luminance
{
    float LuminanceValue;
};

layout(push_constant)uniform PushColourCorrect
{
		ColourCorrectPC pc;
};

// Based on aces filmic tonemapping http://www.oscars.org/science-technology/sci-tech-projects/aces
vec3 aces_tonemap(vec3 color){	
	mat3 m1 = mat3(
        0.59719, 0.07600, 0.02840,
        0.35458, 0.90834, 0.13383,
        0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
        1.60475, -0.10208, -0.00327,
        -0.53108,  1.10813, -0.07276,
        -0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;    
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return clamp(m2 * (a / b), 0.0, 1.0);	
}

void main()
{	
    // Note: Load operations from any texel that is outside of the boundaries of the bound image will return all zeros.
	// vec4 inImg = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.xy) );
	
    vec2 uvs = (vec2(gl_GlobalInvocationID.xy) + 0.5) / imageSize(resultImage);
    vec4 res = texture( sampler2D( inputImage, basicSampler), uvs);
    
    //const float middleGray = 1.03 - 2 / (2 + log10(fAveLogLum+1));
    float middleGray = pc.exposure;
    // Compute scale factor such that average luminance maps to middle gray
    float fLumScale = middleGray / LuminanceValue;
    
    vec3 f3Color = max(res.rgb, vec3(0.0));
    float fInitialPixelLum = max(RGBtoLuminance(f3Color), 1e-10);
    float fScaledPixelLum = fInitialPixelLum * fLumScale;
    vec3 f3ScaledColor = f3Color * fLumScale;

    vec3 result = aces_tonemap(f3ScaledColor);
	
	// also gamma correct before returning   
    result = LinearToGamma(result.rgb);
    
    //result.rgb = vec3(LuminanceValue);
    //Note: Store operations to any texel that is outside the boundaries of the bound image will do nothing.
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result.rgb, 1.0));
}

