#version 460

#include "shader_utility.shader"

layout (local_size_x = 16, local_size_y = 16) in;
layout (set=0, binding = 0) uniform sampler basicSampler;
layout (set=0, binding = 1) uniform textureCube inputImage;
layout (set=0, binding = 2, rgba16f) uniform writeonly imageCube resultImage;

layout( push_constant ) uniform settings
{
    vec4 values;
};

void main()
{	
    ivec2 cubemapSize = textureSize(samplerCube(inputImage, basicSampler), 0);
    ivec2 outputSize = imageSize(resultImage);
	
    ivec3 cubeCoord = ivec3(gl_GlobalInvocationID);
    vec3 worldPos = cubeCoordToWorld(cubeCoord, outputSize);
	// tagent space from origin point
    vec3 normal = normalize(worldPos);
    vec3 up = vec3(0.0, 1.0, 0.0); 
    
    float dotProduct = dot(normal, up); // prevent cross against zero
    if (abs(dotProduct) > 1.0 - EPSILON)
    {
        // If N is nearly parallel to up, choose a different up vector.
        up = vec3(1.0, 0.0, 0.0); // Or any other suitable vector
    }

    vec3 right = normalize(cross(up, normal));
    up = cross(normal, right);
	
    float sampleDelta = 0.025;
    float nrSamples = 0.0;
    vec3 irradiance = vec3(0);    
    
    float clampValue = max(values.x, 1.0);
    
    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
    {
        float sinPhi = sin(phi);
        float cosPhi = cos(phi);
        for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
        {
            float sinTheta = sin(theta);
            float cosTheta = cos(theta);
            // spherical to cartesian, in tangent space
            vec3 sphereCoord = vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
	        // tangent space to world
            vec3 sampleVec = sphereCoord.x * right + sphereCoord.y * up + sphereCoord.z * normal;
	        // world to cube coord
            ivec3 sampleCoord = texCoordToCube(sampleVec, cubemapSize);
            
            vec3 sampledColor = textureLod(samplerCube(inputImage, basicSampler), sampleVec,0).rgb * cosTheta * sinTheta;
            
            irradiance += clamp(sampledColor, 0.0, clampValue); // clamp the colour to usable value
            
            nrSamples++;
        }
    }
    float invTotalSamples = 1.0 / nrSamples;    
    
    irradiance *= PI * invTotalSamples;
    imageStore(resultImage, cubeCoord, vec4(irradiance, 1.0));	
}
